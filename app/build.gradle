apply plugin: 'com.android.application'
apply plugin: 'spoon'
apply plugin: 'hugo'
//apply plugin: 'loglifecycle'
apply plugin: 'checkstyle'
apply plugin: 'pmd'
apply plugin: 'jdepend'



/*
  Project Module metadata, some Project objects are read only but we need to set them for
  a human friendly name/title for our reports so we do this as than we get around the
  default AndroidStudio thing of naming our first app module app.

  For example, even though through Reports displayName are read-only but we can through
  changing xsl and passing vars via ant builder get the header of the report to change to
  reflect our project.ext stuff defined below.
 */
ext {



    //a little groovy syntax sugar and some gradle knowledge gives a nice
    //human style project name rather than default IDE/gradle app name
    ourProjectName = '${rootProject.projectDir.name}'+ '${project.name.capitalize()}'

    ourProjectLead = 'Fred Grott'
    ourProjectDescription = 'basic app showing build script with app source code'
    //javadocFooter = "Copyright 2014-${rootProject.ext.reportBuildDate} by $project.ext.ourProjectLead Apache License 2.0"

    archiveVariant = ['debug','release']
    javadocVariant = ['release']


}



android {
    compileSdkVersion rootProject.ext.ourCompileSdkVersion
    buildToolsVersion rootProject.ext.ourBuildToolsVersion



    defaultConfig {
        applicationId "com.grottworkshop.fgbuildtutorialandroid"
        minSdkVersion rootProject.ext.ourMinSdkVersion
        targetSdkVersion rootProject.ext.ourTargetSdkVersion
        versionCode rootProject.ext.ourVersionCode
        versionName "${rootProject.ext.appVersionMajor}.${rootProject.ext.appVersionMinor}.${rootProject.ext.appVersionPatch}"

        buildConfigField "String", "BUILD_TIME", "\"${rootProject.ext.buildTime}\""

        testApplicationId 'com.grottworkshop.fgbuildtutorialandroid.test'
        testInstrumentationRunner 'com.google.android.apps.common.testing.testrunner.GoogleInstrumentationTestRunner'
        testHandleProfiling true
        testFunctionalTest true
    }
    /*
    dexOptions already handled and set in subprojects block of root
    build.gradle file
     */


    testOptions {
        resultsDir = rootProject.ext.testOptionsResultsDir

    }

    aaptOptions {
        noCompress 'txt'
        ignoreAssetsPattern "!.svn:!.git:!.ds_store:!*.scc:.*:<dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"
    }

    signingConfigs {

        release {
            //props stored in gradle.properties at userhome .gradle subfolder

            storeFile file(FREDGROTT_RELEASE_STORE_FILE)
            storePassword FREDGROTT_RELEASE_STORE_PASSWORD
            keyAlias FREDGROTT_RELEASE_KEY_ALIAS
            keyPassword FREDGROTT_RELEASE_KEY_PASSWORD
        }

    }

    /*
    Enables diamond operator, multi-catch, strings in switches for our
    minSdkVersion to compileSdkVersion range.
     */
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }

    /*
    The android gradle plugin loads a duplicate jacoco plugin thus for
    instrumented unit testing we use the internal duplicate jacoco plugin
    from the android gradle plugin hence only needing the configuration closure.

    Jacoco reports can be generated by rooted emulator with the command:
         $ gradlew createDebugCoverageReport
    Or on rooted connected devices with the command:
         $ gradlew connectedCheck
    Coverage reports will be found in
          build/[reports/coverage
     */
    jacoco {
        version = '0.7.1.20140508213'


    }




    /*
    In normal android mobile dev shops you might have stakeholders that
    you need to show app demos to. I use debug for that purpose, however you can
    init a client build type using debug for that purpose. Remember, it is helpful
    if you rename the apk with appName, build variant, versionCode in the file name and
    of course archive a copy in a zip file with the same file naming scheme.
     */
    buildTypes {

        /*
        We define some buildConfigField defs here to use
         */
        def BOOLEAN = "boolean"
        def TRUE = "true"
        def FALSE = "false"
        def LOG_HTTP_REQUESTS = "LOG_HTTP_REQUESTS"
        def REPORT_CRASHES = "REPORT_CRASHES"
        def ENABLE_VIEW_SERVER = "ENABLE_VIEW_SERVER"
        def ENABLE_SHARING = "ENABLE_SHARING"
        def DEBUG_IMAGES = "DEBUG_IMAGES"


        debug {
            debuggable true
            minifyEnabled false
            // dagger jacaco conflict issue is resolved, dx change after buildtoolsversion 21
            testCoverageEnabled true

            // here we go, versionNameSuffix with build date!
            applicationIdSuffix '.dev'
            versionNameSuffix '-dev-' + rootProject.ext.buildTime

            buildConfigField BOOLEAN, LOG_HTTP_REQUESTS, TRUE
            buildConfigField BOOLEAN, REPORT_CRASHES, FALSE
            buildConfigField BOOLEAN, ENABLE_VIEW_SERVER, TRUE
            buildConfigField BOOLEAN, ENABLE_SHARING, TRUE
            buildConfigField BOOLEAN, DEBUG_IMAGES, TRUE


        }



        release {
            minifyEnabled false

            buildConfigField BOOLEAN, LOG_HTTP_REQUESTS, FALSE
            buildConfigField BOOLEAN, REPORT_CRASHES, TRUE
            buildConfigField BOOLEAN, ENABLE_VIEW_SERVER, FALSE
            buildConfigField BOOLEAN, ENABLE_SHARING, FALSE
            buildConfigField BOOLEAN, DEBUG_IMAGES, FALSE



            /*
            Separate out your proguard rules into files for different areas/groups as it makes it easier to
            update the configurations.
             */
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' , 'proguard-googleplayservices.txt', 'proguard-butterknife.txt','proguard-dagger1.txt','proguard.project.txt'

            applicationIdSuffix '.release'
            versionNameSuffix '-release-' + rootProject.ext.buildTime
            signingConfig signingConfigs.release

        }
    }

    /*
    Lint is already setup as a plugin to iterate over all build variants.
     */
    lintOptions {
        lintConfig file("okio-custom-lint.xml")

        // set to true to turn off analysis progress reporting by lint
        quiet false
        // if true, stop the gradle build if errors are found
        abortOnError false
        // if true, only report errors
        ignoreWarnings true
        // if true, emit full/absolute paths to files with errors (true by default)
        //absolutePaths true
        // if true, check all issues, including those that are off by default
        checkAllWarnings true
        // if true, treat all warnings as errors
        warningsAsErrors true
        // turn off checking the given issue id's
        disable 'TypographyFractions', 'TypographyQuotes'
        // turn on the given issue id's
        enable 'RtlHardcoded', 'RtlCompat', 'RtlEnabled'
        // check *only* the given issue id's
        check 'NewApi', 'InlinedApi'
        // if true, don't include source code lines in the error output
        noLines false
        // if true, show all locations for an error, do not truncate lists, etc.
        showAll true

        // if true, generate a text report of issues (false by default)
        textReport true
        // location to write the output; can be a file or 'stdout'
        textOutput 'stdout'
        // if true, generate an XML report for use by for example Jenkins
        xmlReport true
        // file to write report to (if not specified, defaults to lint-results.xml)
        xmlOutput file("build/reports/lint/lint-report.xml")
        // if true, generate an HTML report (with issue explanations, sourcecode, etc)
        htmlReport true
        // optional path to report (default will be lint-results.html in the builddir)
        htmlOutput file("build/reports/lint/lint-report.html")

        // set to true to have all release builds run lint on issues with severity=fatal
        // and abort the build (controlled by abortOnError above) if fatal issues are found
        checkReleaseBuilds true
        // Set the severity of the given issues to fatal (which means they will be
        // checked during release builds (even if the lint target is not included)
        fatal 'NewApi', 'InlineApi'
        // Set the severity of the given issues to error
        error 'Wakelock', 'TextViewEdits'
        // Set the severity of the given issues to warning
        warning 'ResourceAsColor'
        // Set the severity of the given issues to ignore (same as disabling the check)
        ignore 'TypographyQuotes'


    }

}



/*
Reports get generated and placed in build/spoon/${Test_VARIANT} folder.
To instead of running on all connected devices to execute on a specific
set of devices uncomment devices line and replace serial number with the
serial numbers of devices you want to target.
 */
spoon {
    // devices = ['333236E9AE5800EC']
    debug = true
    //className = 'fully.qualified.TestCase'

    //methodName = 'testMyApp'
}





configurations{
    checkstyle
    pmd
    jdepend
    androidJacocoAgent
    androidJacocoAnt
    javancss

}



dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile rootProject.ext.androidsupportapptcompatv7

    checkstyle rootProject.ext.codeqacheckstyle
    pmd rootProject.ext.codeqapmd
    jdepend rootProject.ext.codeqajdepend
    jdepend rootProject.ext.codeqajdependant
    androidJacocoAgent rootProject.ext.codeqajacoco
    androidJacocoAnt rootProject.ext.codeqajacocoant

    javancss rootProject.ext.codeqajavancss



    compile rootProject.ext.retrofit

    compile rootProject.ext.dagger
    compile rootProject.ext.butterknife

    compile rootProject.ext.otto
    compile rootProject.ext.rxjava
    compile rootProject.ext.timber

    compile rootProject.ext.okhttp
    compile rootProject.ext.okio
    compile rootProject.ext.okhttpurlconnection

    debugCompile rootProject.ext.retrofitmock

    provided rootProject.ext.daggercompiler

    androidTestCompile(rootProject.ext.doubleespresso) {
        exclude group: 'com.squareup.dagger', module: 'dagger'
        exclude group: 'com.android.support', module: 'support-v4'

    }
    androidTestCompile rootProject.ext.doubleespressoandroidsupportv4

    androidTestCompile rootProject.ext.assertjandroid
    androidTestCompile rootProject.ext.assertjandroidsupportv4



    androidTestCompile rootProject.ext.mockito
    androidTestCompile rootProject.ext.dexmaker
    androidTestCompile(rootProject.ext.dexmakermockito) {
        exclude module: 'hamcrest-core'
        exclude module: 'objenesis'
        exclude module: 'mockito-core'

    }

    androidTestCompile rootProject.ext.spoonclient

}

/*
Codeqa and Javadocs accounting for sourceSets and productFlavors is pain-in-the-ass
for android gradle plugin versions 1.x.

Codeqa:
         project.sourceSets still has things empty due to the switch from a
         gradle internal class to the new gradle sourceSet model that involves native.
         Thus, we hack/cheat in that we specify src as soruce with include/exclude so
         that all sourceSets that have source get checked. Findbugs and Jdepend
         get constrained to main SourceSet only.

Javadoc:
         We use an array to manually constrain javadoc task generation to only those
         variants that have sources.
 */

android.applicationVariants.all { variant ->

    //rename apk file  block
    // modified from:
    // https://code.google.com/p/android/issues/detail?id=79123
    // per Nick's(VokalInteractive) example
    // Nick's code did not account for productFlavors[0] being null
    // and the other use cases..mine covers all use cases
    if (variant.productFlavors[0] == null){
        //we need to wrap this to check for is output null and
        //to check that we have an .apk file to rename
        //as we do not rename library aar's
        def oldFile = variant.outputs[0].outputFile
        if (oldFile !=null){
            if (oldFile.name.endsWith('.apk')){
                variant.outputs[0].outputFile = new File(variant.outputs[0].outputFile.parent,
                        project.ext.ourProjectName + "_"
                                + variant.buildType.name + "_"
                                + android.defaultConfig.versionCode + "_"
                                + android.defaultConfig.versionName + ".apk")
            }
        }

    }else{
        def oldFile = variant.outputs[0].outputFile
        if (oldFile != null){
            if (oldFile.name.endsWith('.apk')){
                variant.outputs[0].outputFile = new File(variant.outputs[0].outputFile.parent,
                        project.ext.ourProjectName + "_"
                                + variant.productFlavors[0].name + "_"
                                + variant.buildType.name + "_"
                                + variant.mergedFlavor.versionCode + "_"
                                + variant.mergedFlavor.versionName + ".apk")
            }
        }

    }

    // copy apk block
    if (variant.name in archiveVariant) {
        def taskSuffix = variant.buildType.name.capitalize()
        def version = "${android.defaultConfig.versionCode}(${android.defaultConfig.versionName})"
        def destination = "${rootProject.projectDir}/archive/apks/${project.ext.ourProjectName}/${variant.name}/${version}"
        def assembleTaskName = "assemble${taskSuffix}"
        if (tasks.findByName(assembleTaskName)) {
            def copyAPKTask = tasks.create(name: "archive${taskSuffix}", type: Copy) {
                description "Archive/copy apk and proguard mappings.txt to a versioned folder."
                from("${buildDir}") {
                    include "**/proguard/${variant.buildType.name}/mapping.txt"
                    include "**/apk/${variant.outputs[0].outputFile.name}"
                }
                into destination
                eachFile { file ->
                    file.path = file.name // to get flat copy

                }
                includeEmptyDirs = false

            }
            tasks[assembleTaskName].finalizedBy = [copyAPKTask]
        }

    }

    //javadoc
    if (variant.name in javadocVariant){
        // dynamic javadoc task setup, no automatic hooks
        // by variant as we grab our sourceSet via variants
        task("generate${variant.name.capitalize()}Javadoc", type: Javadoc) {
            description = 'Javadoc of $variant.name'
            group = 'documentaion'
            // When JavaBase plugin loads it only sets two javadocs, title and destinationDir
            // thus if we need different we need to set it ourselves
            title = "$project.ext.ourProjectName $android.defaultConfig.versionCode $android.defaultConfig.versionName API"
            // I do not think JavaBase plugin sets docsDir as I was getting symbol not resolved
            destinationDir = new File("${rootProject.ext.buildDocsBaseDir}/${variant.name}/javadoc")
            source = variant.javaCompile.source
            def myAndroidJar = "${android.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
            def myGooglePlayServicesJar = "${android.sdkDirectory}/extras/google/google_play_services/libproject/google-play-services_lib/libs/google-play-services.jar"
            classpath = files(variant.javaCompile.classpath.files, myAndroidJar, myGooglePlayServicesJar)
            exclude '**/BuildConfig.java'
            exclude '**/R.java'
            options {
                docTitle = "Generated Javadoc for $project.ext.ourProjectName for $variant.name"
                windowTitle = "javadoc:$variant.name"
                memberLevel = JavadocMemberLevel.PROTECTED
                author = true
                header = project.ext.ourProjectName
                footer = "Copyright 2014-$rootProject.ext.reportBuildDate by $project.ext.ourProjectLead Apache License 2.0"
                linksOffline('http://d.android.com/reference', '${android.sdkdirectory}/docs/reference')
                stylesheetFile = new File("${rootProject.ext.javadocsJDK7Stylesheet}")

            }
            doLast {
                copy {

                    from "${project.buildDir}/docs/${variant.name}/javadoc"
                    into "${rootProject.projectDir}/archive/docs/${variant.name}/${android.defaultConfig.versionCode}/javadoc"
                }
            }

        }

    }






}

//Separate into cs and pd via android.sourceSets and
// jd and ce via variants
// with arrays to manually choose which ones get
// dynamically created
/*
CodeQA: We cheat and use folder locations and include/exclude to make sure
the variants are chosen.
 */
task checkstyleAllVariants(type: Checkstyle){
    description = 'Analyzes all variants using checkstyle checks'
    group = 'verification'

    def csXmlOutputFile = new File("build/reports/checkstyle/checkstyle-allvariants.xml")
    def csHtmlOutputFile = new File("build/reports/checkstyle/checkstyle-allvariants.html")

    //we can use annotation of SuppressWarning('checkstyle:rule') to
    //ignore certain violations hence this setting to false
    ignoreFailures = false
    showViolations = true

    //we set source as src so as to include all variants, hence the AllVariants in the TaskName
    source = 'src'
    include '**/*.java'
    exclude '**/gen/**'

    // empty classpath
    classpath = files()

    // need to correct checks file
    configFile = file("${rootProject.projectDir}/config/checkstyle/android_checkstyle_5_7_checks.xml")

    reports {
        xml.enabled = true
        xml.destination = csXmlOutputFile
    }

    doLast{
        if (csXmlOutputFile != null && csXmlOutputFile.exists()){
            ant.xslt(in: csXmlOutputFile, style: '../config/checkstyle/checkstyle-noframes-severity-sorted.xsl', out: csHtmlOutputFile)

        }

    }


}
check.dependsOn("checkstyleAllVariants")

task pmdAllVariants(type:Pmd){
    description = 'completes pmd checks for all variants'
    group = 'verification'

    def pdXmlOutputFile = new File("build/reports/pmd/pmd-allvariants.xml")
    def pdHtmlOutputFile = new File("build/reports/pmd/pmd-allvariants.html")

    //we assume that NOPMD comment might not be enabled through gradle ant builder for this task
    ignoreFailures = true
    consoleOutput = true

    ruleSets = ["java-basic", "java-braces", "java-strings", "java-android", "java-junit"]

    source = 'src'
    include '**/*.java'
    exclude '**/gen/**'




    reports {
        xml.enabled = true
        xml.destination = pdXmlOutputFile
        html.enabled = false

    }

    doLast{
        if (pdXmlOutputFile != null && pdXmlOutputFile.exists()){
            ant.xslt(in: pdXmlOutputFile, style: '../config/pmd/pmd-nicerhtml.xsl', out: pdHtmlOutputFile)
        }

    }



}

check.dependsOn("pmdAllVariants")

task jdependMain(type:JDepend){
    description = 'completes jdepend analysis on main sourceset'
    group = 'verification'

    def jdXmlOutputFile = new File("build/reports/jdepend/jdepend-debug.xml")
    def jdHtmlOutputFile = new File("build/reports/jdepend/jdepend-debug.html")


    // find way to exclude R.class
    classesDir = file('build/intermediates/classes/debug')

    // only can be one output..ie either or
    reports {
        xml.enabled = true
        xml.destination = jdXmlOutputFile
        text.enabled = false
    }

    // for some reason if I bracket this with if xmloutput is not null and exists
    // file not there to see soon enough in the doLast bracket
    doLast{

            ant.xslt(in: jdXmlOutputFile, style: '../config/jdepend/jdepend.xsl', out: jdHtmlOutputFile)


    }


}
check.dependsOn("jdependMain")



/*
javancssMain: Tied to one sourceSet, main, as I cannot fathom any use cases
              where you need to collect ncss stats on androidTest, for example, or
              any other sourceSet. If you do find a case where you need it
              you do iteration through android.sourceSets and if else
              bracket it and check if sourceSet is in javancssSourceSet
              array you define up in the ext block of this build script
              so as to only target sourceSets of interest.

              Remember, when creating a custom task that is not a copy of a
              gradle default one you have to setup your inputs correctly
              in that the folder has to exist, etc.

              DefaultsForTask:
                      abortOnFail false
                      generateReport false
                      format plain
                      packageMetrics true
                      classMetrics true
                      functionMetrics true

 */
task javancssMain  {
    description = 'completes javancss analysis'
    group = 'verification'

    def jsReportsDir = new File("$project.buildDir/reports/javancss")
    jsReportsDir.mkdirs()

    def jsXmlOutputFile = new File("$project.buildDir/reports/javancss/javancss-main.xml")
    def jsHtmlOutputFile = new File("$project.buildDir/reports/javancss/javancss-main.html")

    ant.taskdef(name:'javancss', classname:'javancss.JavancssAntTask', classpath:configurations.javancss.asPath)
    ant.javancss(srcdir:'src/main/java', generateReport:true, outputfile: jsXmlOutputFile, format:'xml')






    ant.xslt(in: jsXmlOutputFile, style: '../config/javancss/javancss2html.xsl',out: jsHtmlOutputFile)





}

check.dependsOn('javancssMain')

task javancssAndroidTest {
    description = 'completes javancss analysis'
    group = 'verification'

    def jsReportsDir = new File("$project.buildDir/reports/javancss")
    jsReportsDir.mkdirs()

    def jsXmlOutputFile = new File("$project.buildDir/reports/javancss/javancss-androidTest.xml")
    def jsHtmlOutputFile = new File("$project.buildDir/reports/javancss/javancss-androidTest.html")

    ant.taskdef(name:'javancss', classname:'javancss.JavancssAntTask', classpath:configurations.javancss.asPath)
    ant.javancss(srcdir:'src/androidTest/java', generateReport:true, outputfile: jsXmlOutputFile, format:'xml')






    ant.xslt(in: jsXmlOutputFile, style: '../config/javancss/javancss2html.xsl',out: jsHtmlOutputFile)





}

check.dependsOn("javancssAndroidTest")
